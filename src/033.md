# Tip #33 尽量...不要使用 panic()

> 原始链接：[Golang Tip #33: Just... Don’t Panic()](https://twitter.com/func25/status/1762455704903029138)
>
> “不要使用 panic()”这句话听起来很激进，但实际上是在生产环境中应遵循的良好实践。

“为何这么说？难道我不能利用 `recover()` 来捕获 `panic()` 吗？”

即使你使用了 `recover()`,也可能无法从 `panic()` 中恢复。下面我来解释一下：
![](./images/033/033_01.png)
(我之前在这篇[推文](https://twitter.com/func25/status/1735369960434831629)也已稍微解释过)

在上面的代码片段中，panic 是在一个新的 goroutine 中发生的（通过 `go panicFunc` 启动）。

关键是，只有 panic 触发和调用 `recover()` 是在同一个 goroutine 中时，使用 `recover()` 才有效。

因此，在主函数中的 defer 函数无法捕获或恢复 panic，尽管尝试了恢复，程序仍然会崩溃。

但这并不是唯一的原因，还有另外两点考量：

1. **在生产环境中，代码必须具备极高的稳健性**
   程序意外崩溃是绝对要避免的，因为它会导致系统宕机，从而影响用户体验，并可能对您的企业声誉造成不利影响。

1. **系统中某一部分的 panic 可能会引发连锁反应**
   这可能导致系统（尤其是在微服务或者分布式系统）中其他部分接连出现故障（可能是级联失败）。

我们来看一个典型例子：
![](./images/033/033_02.png)

上面这种做法并非不可取，但它们鼓励了对 panic 的使用。一个更佳的做法应该如下：
![](./images/033/033_03.png)

当程序返回错误而非 panic 时，你的程序可以根据错误做进行相应的处理，例如：

- 重试操作
- 使用默认值
- 记录详细的调试信息
- 程序终止
- 等等...

这种灵活性对于构建健壮的系统至关重要。

**应当把 panic 作为最后的手段**

- 仅在遇到真正无法恢复的错误时才使用 panic，即如果继续运行程序可能会引发更严重的问题，比如数据损坏或未知行为。
- 在程序初始化阶段，如果一个关键组件启动失败，panic 或许是“可接受的”，因为它表明程序无法按预期运行。
