# Tip #18 在使用者的包中定义接口，而不是提供者的包中定义

> 原始链接：[Define interfaces in the consumer package, not the producer](https://twitter.com/func25/status/1756629777107292231)

我之前在推特上提到过这个话题（https://twitter.com/func25/status/1738890734349201903），但它的重要性使我把它列入了这个tips的列表里。

现在，有 3 个原则需要记住：

1. 在使用者的包中定义接口，而不是提供者的包中定义

   接口应该由使用者（使用这个接口的代码）而不是提供者（实现这些接口的代码）来定义。

   这种方法使得添加一个新的函数实现更容易，不会影响到使用者。

2. 在提供者的包中使用具体类型作为返回值

   这很简单，因为我们没有再提供者的包里定义这个接口。

   它允许我们在这些类型上添加新方法，而不破坏这个 API。

3. 避免过早定义接口

   只在有明确使用场景下定义接口，确保它们是**必要的**且**设计得当的**。

好了，说够了理论和假设。

你有没有做过类似的事情？

![tips018-img1](./images/018/tips018-img1.png)

在 `consoleLogger` 同一个的包中定义 `Logger` 接口。

然后，每当你想使用它时，你在使用者的包中创建接口（？）。

![tips018-img2](./images/018/tips018-img2.png)

我这么做好多年了，不使用 `Logger`，而是使用库的接口。

> “这么做不好吗？”

可能吧

但是遵循我们原则考虑一下这个方法，让我们修改一下它。

首先，这是我们新的提供者的 `logger` 包：

![tips018-img3](./images/018/tips018-img3.png)

1. 我们不再在提供者的包中保留 `Logger` 这个接口了。

2. 在创建一个提供者包中的 `Logger` 时，我们返回一个具体类型，对吧？

3. 我们避免过早的定义接口，不需要猜测使用者需要什么功能。

现在让我们看看我们的使用者是如何用它的呢

![tips018-img4](./images/018/tips018-img4.png)

通过在使用接口的地方(在高级模块中)定义接口，可以确保这些模块依赖于抽象接口而不是具体的实现。

啊，这也可以增强模块化，mock 测试和设计思维。
